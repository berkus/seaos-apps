.TH system 3 "" "" ""
.SH SYNOPSIS
system \- execute command string
.SH ANSI_SYNOPSIS
#include <stdlib.h>
.br
int system(char *
.IR s );
.br

int _system_r(void *
.IR reent ,
char *
.IR s );
.br
.SH TRAD_SYNOPSIS
#include <stdlib.h>
.br
int system(
.IR s )
.br
char *
.IR s ;
.br

int _system_r(
.IR reent ,
.IR s )
.br
char *
.IR reent ;
.br
char *
.IR s ;
.br
.SH DESCRIPTION
Use 
.BR system 
to pass a command string 
.BR *<[s >>
to 
.BR /bin/sh 
on
your system, and wait for it to finish executing.

Use `
.BR system(NULL) '
to test whether your system has 
.BR /bin/sh 
available.

The alternate function 
.BR _system_r 
is a reentrant version. The
extra argument 
.IR reent 
is a pointer to a reentrancy structure.
.SH RETURNS
.BR system(NULL) 
returns a non-zero value if 
.BR /bin/sh 
is available, and
.BR 0 
if it is not.

With a command argument, the result of 
.BR system 
is the exit status
returned by 
.BR /bin/sh .
.SH PORTABILITY
ANSI C requires 
.BR system ,
but leaves the nature and effects of a
command processor undefined. ANSI C does, however, specify that
.BR system(NULL) 
return zero or nonzero to report on the existence of
a command processor.

POSIX.2 requires 
.BR system ,
and requires that it invoke a 
.BR sh .
Where 
.BR sh 
is found is left unspecified.

Supporting OS subroutines required: 
.BR _exit ,
.BR _execve ,
.BR _fork_r ,
.BR _wait_r .
.SH SOURCE
src/newlib/libc/stdlib/system.c
